<?php

/**
 * @file
 * Editable fields module.
 */

/**
 * Implementation of hook_field_formatter_info().
 */
function editablefields_field_formatter_info() {
  $all_types = array_keys(field_info_field_types());
  return array(
    'editable' => array(
      'label' => t('Editable'),
      'field types' => $all_types,
    ),
  );
}

/**
 * Implements hook_library().
 */
function editablefields_library() {
  $libraries['editablefields'] = array(
    'title' => 'Editable Fields',
    'js' => array(
      drupal_get_path('module', 'editablefields') . '/editablefields.js' => array(),
    ),
    'css' => array(
      drupal_get_path('module', 'editablefields') . '/editablefields.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'drupal.form'),
    ),
  );

  return $libraries;
}

function editablefields_fallback_formatter($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  // TODO: we need to support a fallback formatter here.
  $display['module'] = 'text';
  $display['type'] = 'text_default';
  $function = $display['module'] . '_field_formatter_view';
  if (function_exists($function)) {
    return $function($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  }
  else {
    return '';
  }
}

/**
 * Implements hook_field_formatter_view().
 */
function editablefields_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, &$items, $display) {
  $field_name = $field['field_name'];
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

  // See if access to this form element is restricted,
  // if so, skip widget processing and just set the value.
  /*
  if (!entity_access('update', $entity_type, $entity) || !field_access('edit', $field, $entity_type, $entity)) {
    // Can't edit.
    return editablefields_fallback_formatter($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  }
  */

  switch ($display['type']) {
    case 'editable':
      // Inject the HTML form.
      $items = array(0 => array());
      return array(
        0 => drupal_get_form('editablefields_form__' . $entity_type . '__' . $id . '__' . $vid, $entity_type, $entity, $field, $instance, $langcode, $display),
      );
  }
}

/**
 * Implements hook_forms().
 */
function editablefields_forms($form_id) {
  $forms = array();
  if (preg_match('/^editablefields_form_/', $form_id)) {
    $forms[$form_id] = array(
      'callback' => 'editablefields_form',
    );
  }
  return $forms;
}

/**
 * Form builder callback.
 */
function editablefields_form($form, &$form_state, $entity_type, $entity, $field, $instance, $langcode, $display) {
  // TODO: set a #action to a "safe" URL so that forms embedded in Views do not
  // break when the result set displayed in the Views changes.

  // Set #parents to 'top-level' by default.
  $form += array('#parents' => array());

  // Set the base properties of the form.
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  $form['#entity_type'] = $entity_type;
  $form['#bundle'] = $bundle;
  $form['#field'] = $field;
  $form['#instance'] = $instance;
  $form['#langcode'] = $langcode;
  $form['#display'] = $display;
  // TODO: should be wrapped in a !isset().
  $form_state['entity'] = $entity;

  // Set the IDs of the entity.
  $info = entity_get_info($entity_type);
  foreach (array('id', 'revision', 'bundle') as $key) {
    // Objects being created might not have id/vid yet.
    $id = isset($entity->{$info['entity keys']['id']}) ? $entity->{$info['entity keys']['id']} : NULL;
    if (isset($info['entity keys'][$key]) && isset($entity->{$info['entity keys'][$key]})) {
      $form[$info['entity keys'][$key]] = array(
        '#type' => 'value',
        '#value' => $entity->{$info['entity keys'][$key]},
      );
    }
  }

  // Remove the title of the field.
  $instance['label'] = '';

  // Insert the field form.
  $items = $entity->{$field['field_name']};
  $items = isset($items[$langcode]) ? $items[$langcode] : array();
  $form += field_default_form($entity_type, $entity, $field, $instance, $langcode, $items, $form, $form_state);

  // TODO: implement better.
  $wrapper_id = drupal_html_id('editablefields');
  $form['#prefix'] = '<div id="' . $wrapper_id . '">';
  $form['#suffix'] = '</div>';

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#name' => 'op-' . $wrapper_id,
    '#type' => 'submit',
    '#value' => t('Save'),
    '#ajax' => array(
      'callback' => 'editablefields_form_update',
      'wrapper' => $wrapper_id,
      'effect' => 'fade',
      'speed' => 'fast',
    ),
  );

  return $form;
}

/**
 * Ajax callback: process an Ajax submission of the form.
 */
function editablefields_form_update($form, $form_state) {
  if (!empty($form_state['executed'])) {
    // Form executed successfully: return the rendered version of the field.

    // Prevent the forms we might generate here from submitting again.
    $_POST = array();

    $formatted_field = field_view_field($form['#entity_type'], $form_state['entity'], $form['#field']['field_name'], $form['#display'], $form['#langcode']);
    // Remove the wrappers.
    $formatted_field = array_intersect_key($formatted_field, element_children($formatted_field));
    return $formatted_field;
  }
  else {
    // Form failed to properly execute, rerender it.
    return $form;
  }
}

/**
 * Form validation callback: process the fields.
 */
function editablefields_form_validate(&$form, &$form_state) {
  entity_form_field_validate($form['#entity_type'], $form, $form_state);
}

/**
 * Form submit callback: save the field modifications.
 */
function editablefields_form_submit(&$form, &$form_state) {
  $entity = $form_state['entity'];
  entity_form_submit_build_entity($form['#entity_type'], $entity, $form, $form_state);

  // TODO: needs a try / catch.
  entity_save($form['#entity_type'], $entity);
}
